// Copyright 2021-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Code, codeFromString, codeToString } from "./code.js";
import { Any, createRegistry, proto3, protoBase64, } from "@bufbuild/protobuf";
/**
 * ConnectError captures three pieces of information: a Code, an error
 * message, and an optional collection of arbitrary Protobuf messages called
 * "details".
 *
 * Because developer tools typically show just the error message, we prefix
 * it with the status code, so that the most important information is always
 * visible immediately.
 *
 * Error details are wrapped with google.protobuf.Any on the wire, so that
 * a server or middleware can attach arbitrary data to an error. Use the
 * function connectErrorDetails() to retrieve the details.
 */
export class ConnectError extends Error {
    constructor(message, code = Code.Unknown, details, metadata) {
        super(createMessage(message, code));
        this.name = "ConnectError";
        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example
        Object.setPrototypeOf(this, new.target.prototype);
        this.rawMessage = message;
        this.code = code;
        this.metadata = new Headers(metadata !== null && metadata !== void 0 ? metadata : {});
        this.details = [];
    }
}
export function connectErrorDetails(error, typeOrRegistry, ...moreTypes) {
    const typeRegistry = "typeName" in typeOrRegistry
        ? createRegistry(typeOrRegistry, ...moreTypes)
        : typeOrRegistry;
    const details = [];
    for (const data of error.details) {
        try {
            const any = new Any(data);
            const name = any.typeUrl.substring(any.typeUrl.lastIndexOf("/") + 1);
            const type = typeRegistry.findMessage(name);
            if (type) {
                const message = new type();
                if (any.unpackTo(message)) {
                    details.push(message);
                }
            }
        }
        catch (_) {
            //
        }
    }
    return details;
}
/**
 * Create an error message, prefixing the given code.
 */
function createMessage(message, code) {
    return message.length
        ? `[${codeToString(code)}] ${message}`
        : `[${codeToString(code)}]`;
}
/**
 * Parse a Connect error from a JSON value.
 * Will return a ConnectError, but throw one in case the JSON is malformed.
 */
export function connectErrorFromJson(jsonValue, metadata) {
    if (typeof jsonValue !== "object" ||
        jsonValue == null ||
        Array.isArray(jsonValue) ||
        !("code" in jsonValue) ||
        typeof jsonValue.code !== "string") {
        throw newParseError(jsonValue);
    }
    const code = codeFromString(jsonValue.code);
    if (!code) {
        throw newParseError(jsonValue.code, ".code");
    }
    const message = jsonValue.message;
    if (message != null && typeof message !== "string") {
        throw newParseError(jsonValue.code, ".message");
    }
    const error = new ConnectError(message !== null && message !== void 0 ? message : "", code, undefined, metadata);
    if ("details" in jsonValue && Array.isArray(jsonValue.details)) {
        for (const detail of jsonValue.details) {
            if (detail === null ||
                typeof detail != "object" ||
                Array.isArray(detail) ||
                typeof detail.type != "string" ||
                typeof detail.value != "string") {
                throw newParseError(detail, `.details`);
            }
            try {
                error.details.push({
                    typeUrl: "type.googleapis.com/" + detail.type,
                    value: protoBase64.dec(detail.value),
                });
            }
            catch (e) {
                throw newParseError(e, `.details`, false);
            }
        }
    }
    return error;
}
/**
 * Convert any value - typically a caught error into a ConnectError,
 * following these rules:
 * - If the value is already a ConnectError, return it as is.
 * - If the value is an AbortError from the fetch API, return the message
 *   of the AbortError with code Canceled.
 * - For other Errors, return the Errors message with code Unknown by default.
 * - For other values, return the values String representation as a message,
 *   with the code Unknown by default.
 */
export function connectErrorFromReason(reason, code = Code.Unknown) {
    if (reason instanceof ConnectError) {
        return reason;
    }
    if (reason instanceof Error) {
        if (reason.name == "AbortError") {
            // Fetch requests can only be canceled with an AbortController.
            // We detect that condition by looking at the name of the raised
            // error object, and translate to the appropriate status code.
            return new ConnectError(reason.message, Code.Canceled);
        }
        return new ConnectError(reason.message);
    }
    return new ConnectError(String(reason), code);
}
export function newParseError(valueOrError, property, json) {
    let d;
    if (json !== null && json !== void 0 ? json : true) {
        d = proto3.json.debug(valueOrError);
    }
    else {
        property = "";
        d =
            valueOrError instanceof Error
                ? valueOrError.message
                : String(valueOrError);
    }
    return new ConnectError(`cannot decode ConnectError${property !== null && property !== void 0 ? property : ""} from JSON: ${d}`, Code.Internal);
}
