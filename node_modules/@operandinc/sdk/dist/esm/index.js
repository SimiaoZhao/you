import { createConnectTransport, createPromiseClient, } from '@bufbuild/connect-web';
import fetch from 'cross-fetch';
function createHeaderInterceptor(headers) {
    return (next) => async (req) => {
        if (headers) {
            for (const [key, value] of Object.entries(headers)) {
                if (!req.header.has(key) && value) {
                    req.header.set(key, value);
                }
            }
        }
        return await next(req);
    };
}
export const indexIDHeaderKey = 'Operand-Index-ID';
export function operandClient(service, apiKey, endpoint, extraHeaders, forceFetchTransport) {
    const baseUrl = endpoint || 'https://engine.operand.ai';
    const headers = Object.assign(Object.assign({}, extraHeaders), { Authorization: apiKey });
    const transport = hasFetchApi() && !forceFetchTransport
        ? createConnectTransport({
            baseUrl: baseUrl,
            interceptors: [createHeaderInterceptor(headers)],
            jsonOptions: {
                ignoreUnknownFields: true,
            }
        })
        : createNodeFetchTransport(baseUrl, headers);
    return createPromiseClient(service, transport);
}
function hasFetchApi() {
    try {
        new Headers();
        return true;
    }
    catch (_) {
        return false;
    }
}
function createRequestBody(message) {
    return message.toJsonString();
}
function createNodeFetchTransport(baseUrl, headers) {
    return {
        async unary(service, method, _signal, _timeoutMs, _header, message) {
            const endpoint = `${baseUrl}/${service.typeName}/${method.name}`;
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: Object.assign(Object.assign({}, headers), { 'Content-Type': 'application/json' }),
                body: createRequestBody(message instanceof method.I ? message : new method.I(message)),
            });
            if (!response.ok) {
                const body = await response.text();
                const message = `Request failed with code ${response.status}, status ${response.statusText}: ${body}`;
                console.warn(message);
                return Promise.reject(new Error(message));
            }
            return {
                message: method.O.fromJson((await response.json()), {
                    ignoreUnknownFields: true,
                }),
            };
        },
        async serverStream(_service, _method, _signal, _timeoutMs, _header, _message) {
            return Promise.reject(new Error('Not implemented'));
        },
    };
}
import * as V3Connect_1 from './index/v1/index_connectweb.js';
export { V3Connect_1 as V3Connect };
import * as V3Types_1 from './index/v1/index_pb.js';
export { V3Types_1 as V3Types };
export * from './operand/v1/object_connectweb.js';
export * from './operand/v1/object_pb.js';
export * from './operand/v1/operand_connectweb.js';
export * from './operand/v1/operand_pb.js';
export * from './operand/v1/notification_connectweb.js';
export * from './operand/v1/notification_pb.js';
export * from './operand/v1/index_connectweb.js';
export * from './operand/v1/index_pb.js';
