// Copyright 2021-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { MethodKind } from "@bufbuild/protobuf";
import { Code } from "./code.js";
import { makeAnyClient } from "./any-client.js";
import { connectErrorFromReason } from "./connect-error.js";
/**
 * Create a CallbackClient for the given service, invoking RPCs through the
 * given transport.
 */
export function createCallbackClient(service, transport) {
    return makeAnyClient(service, (method) => {
        switch (method.kind) {
            case MethodKind.Unary:
                return createUnaryFn(transport, service, method);
            case MethodKind.ServerStreaming:
                return createServerStreamingFn(transport, service, method);
            default:
                return null;
        }
    });
}
function createUnaryFn(transport, service, method) {
    return function (requestMessage, callback, options) {
        const abort = new AbortController();
        options = wrapSignal(abort, options);
        transport
            .unary(service, method, abort.signal, options.timeoutMs, options.headers, requestMessage)
            .then((response) => {
            var _a, _b;
            (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);
            (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);
            callback(undefined, response.message);
        }, (reason) => {
            const err = connectErrorFromReason(reason, Code.Internal);
            if (err.code === Code.Canceled && abort.signal.aborted) {
                // As documented, discard Canceled errors if canceled by the user.
                return;
            }
            callback(err, new method.O());
        });
        return () => abort.abort();
    };
}
function createServerStreamingFn(transport, service, method) {
    return function (requestMessage, onResponse, onClose, options) {
        const abort = new AbortController();
        async function run() {
            var _a, _b;
            options = wrapSignal(abort, options);
            const streamResponse = await transport.serverStream(service, method, options.signal, options.timeoutMs, options.headers, requestMessage);
            (_a = options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, streamResponse.header);
            let result = await streamResponse.read();
            while (!result.done) {
                onResponse(result.value);
                result = await streamResponse.read();
            }
            (_b = options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, streamResponse.trailer);
            onClose(undefined);
        }
        run().catch((reason) => {
            const err = connectErrorFromReason(reason, Code.Internal);
            if (err.code === Code.Canceled && abort.signal.aborted) {
                // As documented, discard Canceled errors if canceled by the user,
                // but do invoke the close-callback.
                onClose(undefined);
            }
            else {
                onClose(err);
            }
        });
        return () => abort.abort();
    };
}
function wrapSignal(abort, options) {
    if (options === null || options === void 0 ? void 0 : options.signal) {
        options.signal.addEventListener("abort", () => abort.abort());
        if (options.signal.aborted) {
            abort.abort();
        }
    }
    return Object.assign(Object.assign({}, options), { signal: abort.signal });
}
