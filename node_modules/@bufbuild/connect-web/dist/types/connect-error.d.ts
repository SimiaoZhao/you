import { Code } from "./code.js";
import { Any, AnyMessage, IMessageTypeRegistry, JsonValue, Message, MessageType } from "@bufbuild/protobuf";
/**
 * ConnectError captures three pieces of information: a Code, an error
 * message, and an optional collection of arbitrary Protobuf messages called
 * "details".
 *
 * Because developer tools typically show just the error message, we prefix
 * it with the status code, so that the most important information is always
 * visible immediately.
 *
 * Error details are wrapped with google.protobuf.Any on the wire, so that
 * a server or middleware can attach arbitrary data to an error. Use the
 * function connectErrorDetails() to retrieve the details.
 */
export declare class ConnectError extends Error {
    /**
     * The Code for this error.
     */
    readonly code: Code;
    /**
     * A union of response headers and trailers associated with this error.
     */
    readonly metadata: Headers;
    /**
     * When an error is parsed from the wire, error details are stored in
     * this property. They can be retrieved using connectErrorDetails().
     */
    readonly details: Pick<Any, "typeUrl" | "value">[];
    /**
     * The error message, but without a status code in front.
     *
     * For example, a new `ConnectError("hello", Code.NotFound)` will have
     * the message `[not found] hello`, and the rawMessage `hello`.
     */
    readonly rawMessage: string;
    name: string;
    constructor(message: string, code?: Code, details?: AnyMessage[], metadata?: HeadersInit);
}
/**
 * Retrieve error details from a ConnectError. On the wire, error details are
 * wrapped with google.protobuf.Any, so that a server or middleware can attach
 * arbitrary data to an error. This function decodes the array of error details
 * from the ConnectError object, and returns an array with the decoded
 * messages. Any decoding errors are ignored, and the detail will simply be
 * omitted from the list.
 */
export declare function connectErrorDetails<T extends Message<T>>(error: ConnectError, type: MessageType<T>): T[];
export declare function connectErrorDetails(error: ConnectError, type: MessageType, ...moreTypes: MessageType[]): AnyMessage[];
export declare function connectErrorDetails(error: ConnectError, registry: IMessageTypeRegistry): AnyMessage[];
/**
 * Parse a Connect error from a JSON value.
 * Will return a ConnectError, but throw one in case the JSON is malformed.
 */
export declare function connectErrorFromJson(jsonValue: JsonValue, metadata?: HeadersInit): ConnectError;
/**
 * Convert any value - typically a caught error into a ConnectError,
 * following these rules:
 * - If the value is already a ConnectError, return it as is.
 * - If the value is an AbortError from the fetch API, return the message
 *   of the AbortError with code Canceled.
 * - For other Errors, return the Errors message with code Unknown by default.
 * - For other values, return the values String representation as a message,
 *   with the code Unknown by default.
 */
export declare function connectErrorFromReason(reason: unknown, code?: Code): ConnectError;
/**
 * newParseError() is an internal utility to create a ConnectError while
 * parsing a Connect EndStreamResponse or a Connect Error from the wire.
 */
export declare function newParseError(error: unknown, property: string, json: false): ConnectError;
export declare function newParseError(value: JsonValue, property?: string, json?: true): ConnectError;
