"use strict";
// Copyright 2021-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeEnvelopes = exports.createEnvelopeReadableStream = void 0;
const connect_error_js_1 = require("./connect-error.js");
const code_js_1 = require("./code.js");
/**
 * Create a ReadableStream of enveloped messages from a ReadableStream of bytes.
 *
 * Ideally, this would simply be a TransformStream, but ReadableStream.pipeThrough
 * does not have the necessary availability at this time.
 */
function createEnvelopeReadableStream(stream) {
    let reader;
    let buffer = new Uint8Array(0);
    function append(chunk) {
        const n = new Uint8Array(buffer.length + chunk.length);
        n.set(buffer);
        n.set(chunk, buffer.length);
        buffer = n;
    }
    return new ReadableStream({
        start() {
            reader = stream.getReader();
        },
        async pull(controller) {
            let header = undefined;
            for (;;) {
                if (header === undefined && buffer.byteLength >= 5) {
                    let length = 0;
                    for (let i = 1; i < 5; i++) {
                        length = (length << 8) + buffer[i];
                    }
                    header = { flags: buffer[0], length };
                }
                if (header !== undefined && buffer.byteLength >= header.length + 5) {
                    break;
                }
                const result = await reader.read();
                if (result.done) {
                    break;
                }
                append(result.value);
            }
            if (header === undefined) {
                if (buffer.byteLength == 0) {
                    controller.close();
                    return;
                }
                controller.error(new connect_error_js_1.ConnectError("premature end of stream", code_js_1.Code.DataLoss));
                return;
            }
            const data = buffer.subarray(5, 5 + header.length);
            buffer = buffer.subarray(5 + header.length);
            controller.enqueue({
                flags: header.flags,
                data,
            });
        },
    });
}
exports.createEnvelopeReadableStream = createEnvelopeReadableStream;
function encodeEnvelopes(...envelopes) {
    const target = new ArrayBuffer(envelopes.reduce((previousValue, currentValue) => previousValue + currentValue.data.length + 5, 0));
    let offset = 0;
    for (const m of envelopes) {
        offset += encodeEnvelope(m, target, offset);
    }
    return new Uint8Array(target);
}
exports.encodeEnvelopes = encodeEnvelopes;
function encodeEnvelope(envelope, target, byteOffset) {
    const len = envelope.data.length + 5;
    const bytes = new Uint8Array(target, byteOffset, len);
    bytes[0] = envelope.flags; // first byte is flags
    for (let l = envelope.data.length, i = 4; i > 0; i--) {
        bytes[i] = l % 256; // 4 bytes message length
        l >>>= 8;
    }
    bytes.set(envelope.data, 5);
    return len;
}
