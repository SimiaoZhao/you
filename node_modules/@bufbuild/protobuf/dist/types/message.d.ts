import type { BinaryReadOptions, BinaryWriteOptions } from "./binary-format.js";
import type { JsonReadOptions, JsonValue, JsonWriteOptions, JsonWriteStringOptions } from "./json-format.js";
import type { MessageType } from "./message-type.js";
/**
 * AnyMessage is an interface implemented by all messages. If you need to
 * handle messages of unknown type, this interface provides a convenient
 * index signature to access fields with message["fieldname"].
 */
export interface AnyMessage extends Message<AnyMessage> {
    [k: string]: any;
}
/**
 * Message is the base class of every message, generated, or created at
 * runtime.
 *
 * It is _not_ safe to extend this class. If you want to create a message at
 * run time, use proto3.makeMessageType().
 */
export declare class Message<T extends Message<T> = AnyMessage> {
    /**
     * Compare with a message of the same type.
     */
    equals(other: T | PlainMessage<T> | undefined | null): boolean;
    /**
     * Create a deep copy.
     */
    clone(): T;
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): this;
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): this;
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): this;
    /**
     * Serialize the message to binary data.
     */
    toBinary(options?: Partial<BinaryWriteOptions>): Uint8Array;
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options?: Partial<JsonWriteOptions>): JsonValue;
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options?: Partial<JsonWriteStringOptions>): string;
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType(): MessageType<T>;
}
/**
 * PlainMessage<T> strips all methods from a message, leaving only fields
 * and oneof groups.
 */
export declare type PlainMessage<T extends Message> = {
    [P in keyof T as T[P] extends Function ? never : P]: T[P];
};
/**
 * PartialMessage<T> constructs a type from a message. The resulting type
 * only contains the protobuf field members of the message, and all of them
 * are optional.
 *
 * PartialMessage is similar to the built-in type Partial<T>, but recursive,
 * and respects `oneof` groups.
 */
export declare type PartialMessage<T extends Message> = {
    [P in keyof T as T[P] extends Function ? never : P]?: PartialField<T[P]>;
};
declare type PartialField<F> = F extends (Date | Uint8Array | bigint | boolean | string | number) ? F : F extends Array<infer U> ? Array<PartialField<U>> : F extends ReadonlyArray<infer U> ? ReadonlyArray<PartialField<U>> : F extends Message ? PartialMessage<F> : F extends OneofSelectedMessage<infer C, infer V> ? {
    case: C;
    value: PartialMessage<V>;
} : F extends {
    case: string | undefined;
    value?: unknown;
} ? F : F extends {
    [key: string | number]: Message<infer U>;
} ? {
    [key: string | number]: PartialMessage<U>;
} : F;
declare type OneofSelectedMessage<K extends string, M extends Message> = {
    case: K;
    value: M;
};
export {};
